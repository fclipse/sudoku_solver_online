<!-- 2023.12.07 Made By HanSJ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Solver</title>
</head>
<body>
    <div>
        <h1>Sudoku Solver</h1>
        <h3>Made by Hansj</h3>
        <h3>설명</h3>
        <p>csv형식으로 된 파일을 업로드하거나 직접 값을 입력한 후 solve 버튼을 누르세요!</p>
    </div>
    <!--스도쿠 입력 몸체-->
    
    <!--제출 버튼-->
    <div id="main">
        <!-- <input type="color"> -->
        <input type="file" id="fileInput">

        <div class="sudoku-rows"></div>

        <div id="btn-area">
            <input id="solve" type="button" value="Solve!">
            <input id="clear" type="button" value="Clear Values">
        </div>
        <div id="answer-area"></div>
    </div>
    <style>
        input.cell{
    width: 40px;
    height: 40px;
    font-size: 25px;
    text-align: center;
    vertical-align: middle;
    padding: 0px;
    border-width: 1px;
    border-radius: 3px;
}

#main{
    display: flex;
    flex-flow: column;

    align-items: center;

    gap: 30px;
}
#solve, #clear{
    width: 100px;
    height: 60px;
}

.sudoku-rows{
    display:flex;
    flex-flow: column;
    justify-content: center;
    align-items: center;
}

.row{
    display: flex;
    flex-flow: row;
    justify-content: center;
    align-items: center;
}

/* 영역별로 배경 회색으로 칠해줌 */
.sudoku-rows > .row:nth-child(n + 1):nth-child(-n + 3) .cell:nth-child(n + 1):nth-child(-n + 3),
.sudoku-rows > .row:nth-child(n + 1):nth-child(-n + 3) .cell:nth-child(n + 7):nth-child(-n + 9),
.sudoku-rows > .row:nth-child(n + 4):nth-child(-n + 6) .cell:nth-child(n + 4):nth-child(-n + 6),
.sudoku-rows > .row:nth-child(n + 7):nth-child(-n + 9) .cell:nth-child(n + 1):nth-child(-n + 3),
.sudoku-rows > .row:nth-child(n + 7):nth-child(-n + 9) .cell:nth-child(n + 7):nth-child(-n + 9),
#answer-area > .row:nth-child(n + 1):nth-child(-n + 4) .cell:nth-child(n + 1):nth-child(-n + 3),
#answer-area > .row:nth-child(n + 1):nth-child(-n + 4) .cell:nth-child(n + 7):nth-child(-n + 9),
#answer-area > .row:nth-child(n + 5):nth-child(-n + 7) .cell:nth-child(n + 4):nth-child(-n + 6),
#answer-area > .row:nth-child(n + 8):nth-child(-n + 10) .cell:nth-child(n + 1):nth-child(-n + 3),
#answer-area > .row:nth-child(n + 8):nth-child(-n + 10) .cell:nth-child(n + 7):nth-child(-n + 9){
    background-color: #BFBFBF;
}

/* unable 설정 */
.unable{
    text-align: center;
}

#btn-area{
    display: flex;
    flex-flow: row;
    gap: 30px;
}

#answer-area{
    display: flex;
    flex-flow: column;
    align-items: center;
}
    </style>
    <!--소스 파일-->
    <script>
        // screen.js
        // 스도쿠 입력칸 생성
const rows = document.querySelector('.sudoku-rows');

makeSudokuTiles(rows);

// parentDiv에 9*9 sudoku input을 만들어 넣어 주는 함수
function makeSudokuTiles(parentDiv){
    for(let i = 0; i < 9; i++){
        const rowDiv = document.createElement('div');
        rowDiv.classList.add('row');
        rowDiv.id = `row-${i+1}`;
    
        for(let j = 0; j < 9; j++){
            const colDiv = document.createElement('input');
            colDiv.classList.add('cell');
            colDiv.type = 'text';
            colDiv.id = `col-${j + 1}`;
            colDiv.maxLength = '1';
            rowDiv.appendChild(colDiv);
        }
        parentDiv.appendChild(rowDiv);
    }
}

// 입력칸엔 1~9 사이의 입력만 들어오도록 설정
const inputCellList = document.querySelectorAll('.cell');
inputCellList.forEach((cell, index)=>{
    // 값 입력시 1~9 사이 정수만 입력받음 / 다음 cell로 자동으로 이동하는 기능 추가
    cell.addEventListener('input', (event)=>{
        // 입력된 값 얻기
        let inputValue = event.target.value;

        // 정규 표현식을 사용하여 1에서 9 사이의 숫자인지 확인
        let validInput = /^[1-9]$/.test(inputValue);

        // 1에서 9 사이의 숫자가 아닌 경우 입력 방지
        if (!validInput) {
            // 입력을 막음
            event.preventDefault();

            // 기존 입력 값에서 1에서 9 사이의 숫자만 추출
            let sanitizedValue = inputValue.replace(/[^1-9]/g, '');
            
            // 추출한 값으로 input 요소의 값을 업데이트
            event.target.value = sanitizedValue;
        }

        // 입력시 다음 cell로 focus
        if(inputValue.length === cell.maxLength && typeof inputCellList[index + 1] !== 'undefined'){
            inputCellList[index + 1].focus();
        }
    });

    // 화살표 키로 상하좌우로 이동할 수 있도록 설정
    cell.addEventListener('keydown', (event)=>{
        let r = parseInt(index / 9);
        let c = index % 9;

        if(event.key === 'ArrowUp' && index >= 9){
            inputCellList[index - 9].focus();
        }else if(event.key === 'ArrowDown' && index <= 71){
            inputCellList[index + 9].focus();
        }else if(event.key === 'ArrowLeft' && index % 9 > 0){
            inputCellList[index - 1].focus();
        }else if(event.key === 'ArrowRight' && index % 9 < 8){
            inputCellList[index + 1].focus();
        }
    });
});

// loadFile.js
// input 요소 가져오기
const fileInput = document.getElementById('fileInput');

// input 요소에 change 이벤트 리스너 등록
fileInput.addEventListener('change', function(event) {
    // 선택된 파일 가져오기
    const file = event.target.files[0];

    // FileReader 객체 생성
    const reader = new FileReader();

    // 파일 읽기가 완료되면 실행되는 이벤트 리스너 등록
    reader.onload = function(e) {
        // CSV 형식으로 파싱
        const csvData = e.target.result;
        parseCSV(csvData);
    };

    // 파일 읽기 시작
    reader.readAsText(file);
});

// CSV 형식으로 파싱하는 함수
function parseCSV(csvData) {
    // CSV 데이터를 줄 단위로 분할
    const cellList = document.querySelectorAll('.cell');
    const lines = csvData.split('\n');

    // 읽어온 데이터를 input에 저장
    let idx = 0;
    lines.forEach(function(line) {
        line.split(',').forEach((col)=>{
            cellList[idx++].value = col;
        })
        
    });
}

// main.js
// global variables
const len = 9;
const blen = 3; // 블록 길이 설정
const answer_area = document.querySelector('#answer-area');
const sudoku_rows = document.querySelector('.sudoku-rows');
const cellList = sudoku_rows.querySelectorAll('.cell');

// initialize arrays
let user_array = [];
let sudoku_array = [];
for(let i = 0; i < 9; i++){
    user_array.push([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    sudoku_array.push([0, 0, 0, 0, 0, 0, 0, 0, 0]);
}

// solve 버튼 눌렀을 때 스도쿠 풀리게 설정
document.querySelector('#solve').addEventListener('click', ()=>{
    // answer area 초기화
    answer_area.innerHTML = `<h1>Solving...</h1>`;
    
    // 입력된 값들 배열에 가져옴
    init_array();
    
    // 처음부터 불가능한 값이 입력되었는지 확인
    for(let i = 0; i < len; i++){
        for(let j = 0; j < len; j++){
            // 불가능할 경우 -> 해를 구할 수 없습니다 출력
            if(sudoku_array[i][j] !== 0 && !checkValueAvailable(i, j, sudoku_array[i][j])){
                show_unsolvable();
                return;
            }
        }
    }
    
    // 입력된 스도쿠의 해를 구함
    let result = solve_sudoku(0, 0);
    if(!result){
        show_unsolvable();
        return;
    }
    
    // 구한 정답을 출력함
    show_solved();
});

// 구한 해를 출력하는 함수
function show_solved(){
    // console.log(sudoku_array);
    answer_area.innerHTML = `<h1>Answer Values</h1>`;
    makeSudokuTiles(answer_area);
    const answer_cellList = answer_area.querySelectorAll('.cell');
    answer_cellList.forEach((cell, index)=>{
        cell.value = sudoku_array[parseInt(index / 9)][index % 9];
    });
}

// 해를 구하지 못할 경우, 해당 안내문을 띄움.
function show_unsolvable(){
    answer_area.innerHTML = `<h1 class="unable">Unable to solve sudoku.</br>Please enter different Value.</h1>`
}

// 입력된 값들 배열에 가져옴
function init_array() {
    cellList.forEach((cell, index) => {
        let r = parseInt(index / 9);
        let c = index % 9;
        sudoku_array[r][c] = cell.value - '0';
        user_array[r][c] = cell.value - '0';
    });
}

// 백트래킹 알고리즘으로 스도쿠의 해를 구함
function solve_sudoku(r, c){
    // 끝이면 return
    if(r === 9){
        return true;
    }
    // 다음 줄으로 이동
    if(c === 9){
        return solve_sudoku(r + 1, 0);
    }

    if(sudoku_array[r][c]){
        // 값이 있으면 다음 칸으로 넘어감
        return solve_sudoku(r, c + 1);
    }else{
        // 기존에 값이 없으면 해를 구함
        for(let val = 1; val <= 9; val++){
            // 가능한 값이 있다면 해당 값을 입력하고 다음 칸으로 이동함.
            if(checkValueAvailable(r, c, val)){
                sudoku_array[r][c] = val;
                if(solve_sudoku(r, c + 1)){
                    return true;
                }
            }
        }
        // 가능한 값이 없는 경우
        sudoku_array[r][c] = 0; // 바꾼 값은 원래대로 돌려놓음
        return false;
    }
}

// 해당 칸에 value가 들어갈 수 있는지 확인해주는 함수
// 0 <= r, c <= 8
// O(1) ~= O(27)
function checkValueAvailable(r, c, value){
    // 가로세로 확인
    for(let i = 0; i < len; i++){
        if(c !== i && sudoku_array[r][i] === value) return false;
        if(r !== i && sudoku_array[i][c] === value) return false;
    }
    // 3*3 블록 내 확인
    const ir = parseInt(r / 3) * 3; // 기준이 되는 r, c 값
    const ic = parseInt(c / 3) * 3;
    for(let i = 0; i < blen; i++){
        for(let j = 0; j < blen; j++){
            let y = ir + i;
            let x = ic + j;
            if(y !== r && x !== c && sudoku_array[y][x] === value) return false;
        }   
    }
    return true;
}

// clear 버튼 눌렀을 때 sudoku 내 모든 숫자를 지워주는 프로그램
document.querySelector('#clear').addEventListener('click', ()=>{
    cellList.forEach((cell)=>{
        cell.value = ``;
    });
});
    </script>
</body>
</html>